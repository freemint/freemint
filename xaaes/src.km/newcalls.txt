
   This text is NOT, that is _NOT_, official yet, as it is more a collection 
 of notes for myself to remember right now. Consider everything in this 
 textfile unusable/unimplemented unless clearly noted otherwise!

  Intention is that this file will contain documentation on new calls/things 
 added to XaAES. This file will also contain known differences between XaAES 
 and other AES's.

===============================================================================
                            -= Detecting XaAES =-

 XaAES is detected using appl_getinfo(XAAES_GETVERSION); which will return
 in ap_gout1-4 the following;

 ap_gout1 = Major version number
 ap_gout2 = Minor version number
 ap_gout3 = Target platform this XaAES was compiled for
 ap_gout4 = Status (Beta, alpha, etc.)

Add to your header file

#define XA_AGI_VERSION  0x5800

===============================================================================
                       -= New window kind definitions =-

 XaAES now makes use of bit 15 in the 'kind' parameter of wind_create(). Setting
this bit will make XaAES allow for window border sizing without the SIZER gadget
being used.

#define BORDER  0x8000

 I hope this bit is not used for other purposes. This also means there is no
more free bits, and so future extensions will have to require an extended
wind_create() call. As of now, if control[1] has a value of 6 or more, XaAES
will pick up another 16-bits (short) of 'kind' bits from intin[5]. However,
no definitions are made yet.

===============================================================================

                            -= Shading windows =-

   XaAES now supports shading like N.AES and MagiC supports it, except from
 one important point; ALL window status'es remains across
 close_wind()/open_wind() calls, INCLUDING shaded. That means one should
 not rely on the fact that SHADED status will be cleared when one closes
 the window, like other AES's do. Instead, if you want to control SHADE
 status of a window, use the documented;

     wind_set(wh, WF_SHADE, mode, p2, p3, p4)

     'mode' selects wether to SHADE (mode = 1) or UNSHADE (mode = 0) the
     window in question. p2, p3 and p4 are usused at the moment and
     must be set to 0.

===============================================================================
=                            wind_set() extensions                            =
-------------------------------------------------------------------------------

 short wind_set(short handle, short mode,
                short p1, short p2, short p3, short p4);
 {
 	intin[0] = handle;
 	intin[1] = mode;
 	intin[2] = p1;
 	intin[3] = p1;
 	intin[4] = p1;
 	intin[5] = p1;
 }

 GEM arrays as follows:

	Address     Element    meaning 
        ------------------------------------------------------
        control    control[0]   105        # Opcode
        control+2  control[1]   6          # Entries in intin
        control+4  control[2]   1 (or 5)   # Entries in intout (XaAES only)
        control+6  control[3]   0          # Entries in addrin 
        control+8  control[4]   0          # entries in addrout 
        intin      intin[0]    handle
        intin+2    intin[1]    mode
        intin+4    intin[2]    p1
        intin+6    intin[3]    p2
        intin+8    intin[4]    p3
        intin+10   intin[5]    p4
        intout     intout[0]   Return value (1 = OK, 0 = error)

      XaAES uses the following extra output elements if control[2]
      indicates the application wants it:

        intout+2   intout[1]
        intout+4   intout[2]
        intout+6   intout[3]
        intout+8   intout[4]

 XaAES wind_set() extensions;
...............................................................................
 wind_set(handle, WF_CURRXYWH, x, y, w, h);

   Compatible with all other AES's, except from the following points;

   1. If x, y, w and h all have a value of -1, XaAES ignores the call,
      but fills in any return values when needed (see below).
   2. x and y values of -1 are 'legal', i.e, one cannot use -1 to use
      any old x value. Ofcourse, x and y coordinates are checked to be
      inside the rootwindow (not X when noleft = false).
   3. When h have a value of 0, the window is infact shaded. This is a thing
      N.AES does with MiNTSetter, altho I'm not sure this is correct.
      The application is sent a WM_SHADED. On the next
      wind_set(handle, WF_CURRXYWH,...) where the h coordinate is not equal
      to the window's shaded height, the window is unshaded. While the
      window is shaded via this method, shift-clicks on the window title to 
      shade a window is ignored.

   Placing a value of 5 in control[2]:
   1. XaAES returns the CURRXYWH of the new position the window was moved to,
      removing the need for a wind_get(handle, WF_CURRXYWH,...) call.

  Note: wind_set(handle, WF_CURRXYWH, -1, -1, -1, -1); will return exactly
        the same as wind_get(handle, WF_CURRXYWH);
...............................................................................
 wind_set(handle, WF_PREVXYWH, x, y, w, h);

   If either x, y, w or h have a value of -1, that coordinate is not changed.
   If ALL coordinates have a value of -1, the window is actually moved to the
   current PREVXYWH coordinates, making the current window position the new
   PREVXYWH position.

   Placing a value of 5 (or more) in control[2]:
     1. XaAES returns the resulting PREVXYWH, which the window will be moved to
        on the next use of the FULLED gadget or...
     2. When all coordinates passed have a value of -1, XaAES return the
        CURRXYWH of the new position the window was moved to, removing the
        need for a wind_get(handle, WF_CURRXYWH,...) call.
 
-------------------------------------------------------------------------------
 wind_set(handle, WF_FULLXYWH, x, y, w, h);

   If either x, y, w or h have a value of -1, that coordinate is not changed.
   If ALL coordinates have a value of -1, the window is actually moved to the
   current FULLXYWH coordinates, making the current window position the new
   PREVXYWH position.

   Placing a value of 5 (or more) in control[2]:
     1. XaAES returns the resulting FULLXYWH, which the window will be moved to
        on the next use of the FULLED gadget or...
     2. When all coordinates passed have a value of -1, XaAES return the
        CURRXYWH of the new position the window was moved to, removing the
        need for a wind_get(handle, WF_CURRXYWH,...) call.
 
-------------------------------------------------------------------------------
 wind_set(handle, WF_OPTS, mode, hi_opts, lo_opts, 0);

  mode       0 = clear, 1 = set option bits
  hi_opts    upper 16 bits of option bitmask
  lo_opts    lower 16 bits of option bitmask

Currently available options are as follows;

#define WO_WHEEL	0x00000001
 Setting this bit will enable extended mouse wheel support, and go into
 WHL_AROWWHEEL mode causing XaAES to send extended WM_ARROWED messages
 to the application when the mouse wheel turns. Read section "XaAES and
 wheel mouse handling." for details.

#define WO_FULLREDRAW	0x00000002
 Setting this bit will make XaAES send WM_REDRAW messages to cover the
 whole work-area of the window when it is FULLED. Default behaviour is
 to only send WM_REDRAW messages for the areas that need it, blitting
 the already visible parts. This can also be configured via xaaes.cnf,
 see the app_options argument 'naesff'.

#define WO_NOBLITW	0x00000004
 Setting this bit will make XaAES send WM_REDRAW messages to cover the
 whole work-area of the window when its WIDTH changes. This is handy
 for apps like HighWire, Textprocessors ,etc, that need to reformat
 when window width changes. Default behaviour is to send WM_REDRAW
 messages for the areas that need it.

#define WO_NOBLITH	0x00000008
 Setting this bit will make XaAES send WM_REDRAW messages to cover the
 whole work-area of the window when its HEIGHT changes.
 Default behaviour is to send WM_REDRAW messages for the areas that
 need it.

#define WO_SENDREPOS	0x00000010
 Setting this bit will make XaAES send a WM_REPOSED(38) message when a
 windows X/WIDTH and/or Y/HEIGHT coordinate pair changes. Such changes
 happes when the user resizes the window using upper/left borders.
 Default behaviour is to first send a WM_MOVED followed by a WM_SIZED
 message under these conditions, because older apps dont evaluate the
 WIDTH/HEIGHT in WM_MOVED messages. So, dudes, set this bit and use
 WM_REPOSED! :)

 usage: 'opts' is a unsigned long containing the options bits;
      wind_set(handle, 1, opts >> 16, (short)opts, 0); to set selected bits
      wind_set(handle, 0, opts >> 16, (short)otps, 0); to clear selected bits

-------------------------------------------------------------------------------
===============================================================================
                       XaAES and wheel mouse handling.

  This has changed a little compared to the original documentation and
 implementation. When the wheel is on a window whose owner dont know about
 mouse wheels at all, normal WM_ARROWED messages are sent, regardless wether
 the window has ARROW gadgets or not.
  There is no extra info added to these messages in this case, as it were in
 the original implementation.

  Currently mouse wheel events are sent to the owner of the window underneath
 the mouse pointer in all cases except when owner of mouse_lock() is waiting
 for MU_WHEEL.

  For programmers who want to take advantage of mouse wheels in a better way,
 here's an overview;

  wind_set(handle, WF_WHEEL, mode, wheel_mode, 0, 0);

  handle      Window handle, or 0 if one wants settings to apply to all windows
              opened hereafter by the application.
  
  mode        0 = Turn extended wheel awareness off, 1 = Turn on.
  
  wheel_mode
           WHL_REALWHEEL ( 0 )
              When wheel_mode is set to 0 (XWHL_REALWHEEL), XaAES will send
              real wheel messages, constructed as follows;

              msg[0] = WM_WHEEL ( 345 )
              msg[1] = ID of sender
              msg[2] = ...
              msg[3] = window handle
              msg[4] = Mouse X
              msg[5] = Mouse Y
              msg[6] = keyboard shift status
              msg[7] = Wheel info
  
              'wheel info' consists of the following data;
              bits 0-7    - Wheel amount
              bits 8-11   - orient
              bits 12-15  - Wheel ID
 
              'orient' is a bitmask where bit 0 indicates direction, and
              bit 1 indicates orientation;

               bit 0  -  0 = up or left
                         1 = down or right
               bit 1  -  0 = vertical (bit 0 indicates UP/DOWN)
                         1 = horizontal (bit 0 indicates LEFT/RIGHT)

              'wheel ID' contains the wheel number. 0 is wheel #1, etc..
              'wheel amount' holds the number of wheel-turns.
      
           WHL_AROWWHEEL ( 1 ) This is the default wheel_mode set if the
              value passed is outside the available range. When this mode is
              selected, extended WM_ARROWED messages are sent upon each wheel
              turn. With this mode, only one WM_ARROWED message is send if
              configured to scroll more than one line per wheel turn. This
              means the application must check, and scroll the appropriate
              number of lines indicated by bits 8-15 in msg[4];
              
              msg[0] = WM_ARROWED
              ...
              msg[4] = Extended, see below.
              msg[5] = Mouse X
              msg[6] = Mouse Y
              msg[7] = keyboard shift status

              There is extended info in msg[4] with this mode, layed out as
              follows;
                       bits 0-2 -  WA_xxx (same as in the original WM_ARROWED
                                   messages, a value between 0 and 7)
                                   bits 3-7 -  unused.
                       bits 8-15 - Number of lines to scroll (unsigned byte)
     
                     This makes it possible for wheel aware applications to
                     scroll the required amount instantly, wihtout receiveing
                     more than this one extended WM_ARROWED.

           WHL_SLDRWHEEL ( 2 )
              When wheel_mode is set to 2 (XHWL_SLDRWHEEL), XaAES converts
              wheel turns into slider movements. XaAES sends standard
              WM_VSLID/WM_HSLID messages reflecting the wheel turns.
              For this to work, WF_VSLIDE/WF_HSLIDE wind_get/set() modes have
              been extended. When the application gets the WM_xSLIDE message,
              it must pass back the position from the message unmodified
              together with your modified position;

              wind_set(handle, WF_[V,H]SLIDE, postion, unmodified, 0, 0);

              Even if the application snaps slider movements and finds that
              the slider does not move, it has to pass back the unmodified
              slider position via wind_set(). In cases where the original
              slider position match the prevsiously set position, XaAES does
              not set or redraw the slider. But it needs to collect the 'real'
              position of the slider for wheel -> slider calculations to work.

      
-------------------------------------------------------------------------------
===============================================================================
                  New event/poll functions - One entry point!


 xevnt_multi(short mode,
             struct xevnt_mask *in_events,
             struct xevnt_mask *out_events,
             struct xevents *inevents,
             struct xevents *outevents);

 GEM arrays as follows:

	Address     Element    meaning 
        ------------------------------------------------------
        control    control[0]   Yes.. what? # Opcode
        control+2  control[1]   1           # Entries in intin
        control+4  control[2]   4           # Entries in intout (XaAES only)
        control+6  control[3]   4           # Entries in addrin 
        control+8  control[4]   0           # entries in addrout 

        intin      intin[0]    mode (0 = block, 1 = setup for poll, 2 = read)
        addrin     addrin[0]   Address of struct xevent_mask, conaining a
                               bit mask denoting events to use.
        addrin     addrin[1]   Address of struct xevnt_mask into which XaAES
                               writes events that occured.
        addrin+4   addrin[2]   Address of a struct xevents containing event
                               criterias.
        addrin+8   addrin[3]   Address of a struct xevents that XaAES will
                               modify according to events happening when in
                               block-mode.

        intout     intout[0]   Return value (1 = OK, 0 = error)
        intout+2   intout[1]   Mouse X coordinate
        intout+4   intout[2]   Mouse Y coordinate
        intout+6   intout[3]   Keyboard shift status


 xevnt_poll(struct xevent_mask *events);

 GEM arrays as follows:

	Address     Element    meaning 
        ------------------------------------------------------
        control    control[0]   Yes.. what? # Opcode
        control+2  control[1]   0           # Entries in intin
        control+4  control[2]   4           # Entries in intout (XaAES only)
        control+6  control[3]   1           # Entries in addrin 
        control+8  control[4]   0           # entries in addrout 

        addrin     addrin[0]   Address of struct xevent_mask, conaining a
                               bit mask denoting events to use.

        intout     intout[0]   Return value (1 = OK, 0 = error)
        intout+2   intout[1]   Mouse X coordinate
        intout+4   intout[2]   Mouse Y coordinate
        intout+6   intout[3]   Keyboard shift status

struct xevent_mask
{
  unsigned long events3;
  unsigned long events2;
  unsigned long events1;
  unsigned long events0;
};

struct xevnts
{
  struct evnt_mu_keyboard  *e_kbd;
  struct evnt_mu_button    *e_but;
  struct evnt_mu_m1        *e_mu1;
  struct evnt_mu_m1        *e_mu2;
  struct evnt_mu_mx        *e_mx;
  struct evnt_mu_mesag     *e_mesag;
  struct evnt_mu_timer     *e_timer;
  struct evnt_mu_fselect   *e_fselect;
  struct envt_mu_pmsg      *e_pmsg;
  long reserved[64-8];
};

struct evnt_mu_keyboard
{
  unsigned short scan;
  unsigned short ascii;
  unsigned short aes;
  unsigned short norm;
  unsigned short kstate;
};

struct evnt_mu_button
{
  short clicks;
  short mask;
  short state;
  short kstate;
  short x, y;
};

struct evnt_mu_mr
{
  short x, y, w, h;
  short flag;
};

struct evnt_mu_mx
{
  short reserved;
};

struct evnt_mu_mesag
{
  short type;
  short id_sender;
  short len;
  short data[16-3];
};

struct evnt_mu_timer
{
  long delta;
};

struct evnt_mu_pmsg
{
  long userlong1;
  long userlong2;
  short pid;
  short reserved[16-5];
};

struct evnt_mu_fselect
{
  long timeout;
  unsigned long rfds;
  unsigned long wfds;
  short reserved[16-6];
};
